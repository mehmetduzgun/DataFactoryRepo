{
	"name": "flow1",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "GenericDataset1",
						"type": "DatasetReference"
					},
					"name": "sourcefile"
				},
				{
					"dataset": {
						"referenceName": "SqlDimension",
						"type": "DatasetReference"
					},
					"name": "bestaandedbtabel"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "dbtest1",
						"type": "DatasetReference"
					},
					"name": "DimensionTableSink"
				}
			],
			"transformations": [
				{
					"name": "AddHashInput"
				},
				{
					"name": "NewAndUpdatedRows"
				},
				{
					"name": "Filter1"
				},
				{
					"name": "AddHashExisting"
				},
				{
					"name": "AddKey"
				},
				{
					"name": "FilterForUpdatedValues"
				},
				{
					"name": "GetMaxSurrogateKey"
				},
				{
					"name": "Join1"
				},
				{
					"name": "AddDimensionColumns"
				},
				{
					"name": "UpdateObsolete"
				},
				{
					"name": "DropUnwantedColsInput"
				},
				{
					"name": "MarkAsUpdate"
				},
				{
					"name": "DropUnwantedColumns"
				},
				{
					"name": "MarkAsInsert"
				},
				{
					"name": "Union1"
				}
			],
			"script": "parameters{\n\tPrimaryKey as string ('ID'),\n\tColumns as string ('voornaam,achternaam,geboortedatum')\n}\nsource(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> sourcefile\nsource(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> bestaandedbtabel\nsourcefile derive(ID_hash = md5(byName($PrimaryKey)),\n\t\tColumns_hash = md5(byNames(split($Columns,',')))) ~> AddHashInput\nAddHashInput, AddHashExisting exists(AddHashInput@ID_hash == AddHashExisting@ID_hash,\n\tnegate:true,\n\tbroadcast: 'auto')~> NewAndUpdatedRows\nbestaandedbtabel filter(toInteger(byName('Active')) == 1) ~> Filter1\nFilter1 derive(ID_hash = md5(byNames(split($PrimaryKey,','))),\n\t\tColumns_hash = md5(byNames(split($Columns,',')))) ~> AddHashExisting\nNewAndUpdatedRows keyGenerate(output(Key as long),\n\tstartAt: 1L) ~> AddKey\nAddHashExisting, NewAndUpdatedRows exists(AddHashExisting@ID_hash == AddHashInput@ID_hash,\n\tnegate:false,\n\tbroadcast: 'auto')~> FilterForUpdatedValues\nAddHashExisting aggregate(MaxSurrogateKey = max(toInteger(byName('Key')))) ~> GetMaxSurrogateKey\nAddKey, GetMaxSurrogateKey join(Key == MaxSurrogateKey || true(),\n\tjoinType:'cross',\n\tbroadcast: 'right')~> Join1\nJoin1 derive(Key = Key + MaxSurrogateKey,\n\t\tActive = 1,\n\t\tActiveStartTime = currentUTC(),\n\t\tActiveEndTime = toTimestamp(toString(null()))) ~> AddDimensionColumns\nFilterForUpdatedValues derive(Active = 0,\n\t\tActiveEndTime = currentUTC()) ~> UpdateObsolete\nAddDimensionColumns select(mapColumn(\n\t\teach(match(!in(['id_hash','columns_hash','MaxSurrogateKey'],name)))\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> DropUnwantedColsInput\nUpdateObsolete alterRow(updateIf(true())) ~> MarkAsUpdate\nMarkAsUpdate select(mapColumn(\n\t\teach(match(!in(['id_hash','columns_hash','MaxSurrogateKey'],name)))\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> DropUnwantedColumns\nDropUnwantedColsInput alterRow(insertIf(true())) ~> MarkAsInsert\nMarkAsInsert, DropUnwantedColumns union(byName: true)~> Union1\nUnion1 sink(input(\n\t\tID as string,\n\t\tvoornaam as string,\n\t\tachternaam as string,\n\t\tgeboortedatum as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:[($PrimaryKey)],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> DimensionTableSink"
		}
	}
}